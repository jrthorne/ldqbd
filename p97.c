#include"matutil.h"/* extermal variables whose scope is this source code and matmain.c */    extern matrix_ptr a, s, s0;    extern float lambda;    extern float theta;    extern float mu;/*************************************************************************//* J1.8 q_gen follows model on page 97 */matrix_ptr q_gen(int dim, int k){    matrix_ptr Q = salloc(3);    matrix_ptr A, B;    float elem;    int i, j, p;/* begin */    /* Q0 */    A = identity_gen(dim);    B = matscalmult(lambda, *A);    Q->row = dim;    Q->col = dim;    Q->element = (float *) calloc(dim*dim, sizeof(float));    mat_copy(Q, B);    free_matrix(A);    free_matrix(B);    /* Q1 */    (Q+1)->row = dim;    (Q+1)->col = dim;    (Q+1)->element = (float *) calloc(dim*dim, sizeof(float));    for (i=0; i<dim; i++)        for (j=0; j<dim; j++) {            p = i*dim + j;            if (i==j)                *((Q+1)->element+p) = -k*theta - i*mu - lambda;            else if (i==(j+1))                *((Q+1)->element+p) = i*mu;            else                *((Q+1)->element+p) = 0.0;            /* end switch */       } /* next j */    /* Q2 */    (Q+2)->row = dim;    (Q+2)->col = dim;    (Q+2)->element = (float *) calloc(dim*dim, sizeof(float));    for (i=0; i<dim; i++)        for (j=0; j<dim; j++) {            p = i*dim + j;            if (i==(j-1))                *((Q+2)->element+p) = k*theta;            else                *((Q+2)->element+p) = 0.0;        }   /* next j */    return Q;} /* end q_gen *//*************************************************************************//* q_gen (becomes q_generate in J1.8) generates the elements of the matrix Q */matrix_ptr q_generate(int dim, int k){   /* A row of Q consists of at most 3 elements, which can in themselves      be matricies */   matrix_ptr Q = salloc(3);   matrix_ptr A, B, C;  /* helpful storage */   int temp, i, j;/* begin */    switch (k) {        case -1 :       /* transpose a */            temp = a->row;            a->row = a->col;            a->col = temp;            Q = matscalmult(lambda, *a); /* Q0 */           /* return a to normal */            temp = a->row;            a->row = a->col;            a->col = temp;            (Q+1)->row = 1;            (Q+1)->col = 1;            (Q+1)->element = (float *) malloc(sizeof(float));            *(Q+1)->element = -lambda;  /* Q1 */            (Q+2)->row = 0;            (Q+2)->col = 0;            (Q+2)->element = (float *) NULL; /* Q2 */        break;        case 0 :            A = identity_gen(dim);            B = matscalmult(lambda, *A);        /* Q0 */            Q->row = dim;            Q->col = dim + 1;            Q->element = (float *) calloc(dim*(dim+1), sizeof(float));            for (i=0; i<dim; i++) { /* dim rows */                *((Q->element)+i*(dim+1)) = 0.0;                for (j=0; j<dim; j++) /* dim cols + 1 from above */                    *((Q->element)+(i*(dim+1) + j + 1)) =                                  *((B->element)+(i*dim+j));            }            /* Q1 */            *(Q+1) = *mattake(*s, *B);            /* Q2 */            *(Q+2) = *s0;            free_matrix(B);            free_matrix(A);        break;        default:            A = identity_gen(dim);            B = matscalmult(lambda, *A);            /* Q0 */            Q->element = (float *) calloc((dim+1)*(dim+1), sizeof(float));            Q->row = dim + 1;            Q->col = dim + 1;            for (i=0; i<(dim+1); i++) /* the first row */                *(Q->element+i) = 0.0;            /* The rest of the rows */            for (i=1; i<(dim+1); i++) { /* dim + 1 rows */                *((Q->element)+i*(dim+1)) = 0.0;                for (j=0; j<dim; j++) /* dim cols + 1 from above */                    *((Q->element)+(i*(dim+1) + j + 1)) =                                  *((B->element)+((i-1)*dim+j));            }            /* Q1 */            (Q+1)->element = (float *) calloc((dim+1)*(dim+1), sizeof(float));            (Q+1)->row = dim + 1;            (Q+1)->col = dim + 1;            /* the first row */            *((Q+1)->element) = -(k*theta + lambda);            for (i=1; i<(dim+1); i++)                *((Q+1)->element+i) = *(a->element+(i-1))*lambda;            /* The rest of the dim+1 rows */            C = mattake(*s, *B); /* S - lambda * I  in bottom RHS */            for (i=1; i<(dim+1); i++) { /* dim + 1 rows (one already filled) */                /* s0 in bottom LHS */                *(((Q+1)->element)+i*(dim+1)) = *(s0->element+(i-1));                for (j=0; j<dim; j++) /* dim cols + 1 from above */                    *(((Q+1)->element)+(i*(dim+1) + j + 1)) =                                  *((C->element)+((i-1)*dim+j));            }            /* Q2 */            if (k == 1) {                (Q+2)->row = dim+1;                (Q+2)->col = dim;                (Q+2)->element = (float *) calloc((dim+1)*dim, sizeof(struct matrix_type));                for (i=0; i<dim; i++)                    *((Q+2)->element+i) = *(a->element+i) * theta;                for (i=dim; i<dim*(dim+1); i++)                    *((Q+2)->element+i) = 0.0;            } else {                (Q+2)->row = dim+1;                (Q+2)->col = dim+1;                (Q+2)->element =                         (float *) calloc((dim+1)*(dim+1), sizeof(float));                *((Q+2)->element) = 0.0; /* top LHS element */                for (i=1; i<(dim+1); i++)  /* a transpose * k * theta */                    *((Q+2)->element+i) =                                *(a->element+(i-1))*theta* (float) k;                /* all the rest are zeroes. What a waste of storage! */                for(i=(dim+1); i<(dim+1)*(dim+1); i++)                    *((Q+2)->element+i) = 0.0;            }            free_matrix(A);            free_matrix(B);        break;    }/* testies    fprintf(report, "The matrix Q0\n");    write_matrix(Q);    fprintf(report, "\n");    fprintf(report, "The matrix Q1\n");    write_matrix(Q+1);    fprintf(report, "\n");    fprintf(report, "The matrix Q2\n");    write_matrix(Q+2);    fprintf(report, "\n");*/    return Q;} /* end q_gen */